---
layout: post
title: Git commits messages and history
subtitle: A reflection on how to use Git commits to document changes and decisions
tags: git
---

Git is a very powerful tool, that can be used to more than just archiving code and give you the possibility to revert and track changes.
If you use it wisely, even if you don't have the git-foo powers your project can benefit from it.

Sometimes, while browsing around some code on github or gitlab I struggle to find some reasoning for changes,
why those files we're changed or why something was implemented that way.

The climax is when you found a commit message with tons of changes, spread across several files and the commit message:
`misc fixes`. 

Transposing this to a company project, I believe it's even more important, because people come and go to the projects and we
sometimes struggle to find the reasoning for changing or why the develop choose that approach instead of another one.
If there's no place with that information, we're left in the dark and may start to do some changes and will wither be rejected
at review time (in the best case) or released in production and lead to unexpected behaviour (in case the change was made due some restrictions).

So what can we do to avoid this and save precious developer hours or, for someone like me, who's very found of cheese and
tend to forget the reasoning's after sometime?

Use, what you already need to write: the commit message!

# Unleash the power of the commit messages

In order to make the best use the of Git utilities to work with commits history we must follow some rules. If you're not
used to them, it may looks too overwhelming at the beginning, but after a fer commits you'll start to see the light and benefit from them. Also a good place to start enforcing these is in the code review process, including the format and content of commit messages as part of the review process.

## What to include in the commit message

Every commit message should answer three simple questions: Why? How? What?

### Why this change is needed?

This change may fix a bug, add a feature, improve performance, reliability, stability, readability, etc.
This information will help the reviewer or person looking through the project history to identify the reason that lead to the code change.

### How this change will fulfil his purpose?

High level description of what have been done and what approach was taken to fulfil the requirements. If there's alternative approaches that we're tried and failed, I like to enumerate them along with their downsides to better justify the approach taken.

### What will this change affect the system?

What are the side-effects of this change.

# The format of the commit messages

In this section I will give an example of what is considered a good commit message. Note that I'm not the creator of this format, it's just a mere observation of other projects best practices with some reasoning around.

    Short summary with less than 50 chars

    Body of the commit message, with the explanation of why we need this change, what changed and what are
    the side effects. Use at most 72 chars per line and in the imperative, like "Fix bug" and not "Fixed bug".

    You can split your message by paragraphs, but make sure you add an empty line between them.

     - Use bullet points whenever you need to enumerate things

    Issue references or commands

you may wonder that the last line means, but if you use GitHub or GitLab you can use `Issue #1` to mention the issue that this commit is related or `Closes #1` to state that this commit will fix and close the issue, Make sure you search for the available commands from your provider.

# Reasoning about some conventions here

## 50 chars summary

  This will be converted as the Pull/Merge request title, also allow to quickly identify the changes

## Empty line after summary

  That's the obvious separation between the title and the body

## 72 char lines

-   `git log` does not do any special special wrapping of the commit messages. With an 80 char terminal, we'll have to have room for identation.
-   GitHub/GitLab don't break lines
-   An exception to this rule can be applied when quoting something or other text with a _special_ formatting.   

## Use of the imperative

Because it matches  with commit messages generated by commands like `git merge` and `git revert` and consistency is a odd thing.

# Useful tips for a sane commit history

## Never user git commit -m
  This way, you will ever have an proper editor window

## Never mix two changes in the same commit

  If your commit addresses one issue, solve that issue in only one commit, if you need other changes, add as much commit messages as you need. For example if an issue needs an updated on you dependencies, add one commit to update it and then another to address the issue. Remember that in Git history, like the real world, order is important.

## Make sure every commit is green

  Every commit should pass you CI,

## Use squash and fixup

By the sum of the previous two, sometimes we need to have intermediary commits with smaller changes or experiments. It's OK to have them, but remember to squash or fixup them, before the Pull/Merge Request.


# Bonus content

## How to squash commits


## How to configure Vim as your git editor and enforce this rules

Add the editor to the core section of your `.gitconfig` file:

```
[core]
        editor = vim
```

### Use Vim as git editor

### Configure vim

Personally I would recommend to use vim-fugitive plugin, but adding this line to your `.vimrc` also work as a minimalist solution:
`autocmd Filetype gitcommit setlocal spell textwidth=72`

To know more about vim-fugitive check it's page at https://github.com/tpope/vim-fugitive


<https://github.com/mozilla/pdf.js/wiki/Squashing-Commits>
